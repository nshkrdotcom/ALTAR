An initial overview specification for the new design of the GRID protocol is presented below, synthesizing the identified complexities and concerns from the provided discussion and codebase analyses.

### **GRID v2.0: Initial Overview Specification**

#### **1. Introduction & Vision**

The **GRID (Global Runtime & Interop Director) Protocol** provides the secure, scalable, and polyglot execution layer for the ALTAR ecosystem. It is the production-grade fulfillment layer for tools developed locally using the LATER protocol, solving critical security, governance, and operational challenges inherent in distributed AI agent systems.

This specification is a redesign based on lessons from the `snakepit` and `dspex` codebases. It directly addresses complexities related to multi-language development workflows, testing strategies, and future-proofing the architecture.

The core of GRID remains a **Host-Runtime model**, where a central Elixir Host orchestrates tool calls to distributed, polyglot Runtimes (e.g., Python, Elixir). This architecture provides a seamless **"promotion path"** for tools from local development to a managed production environment.

---

#### **2. Core Concepts & Architecture**

The GRID ecosystem consists of three primary components:

*   **Host (Elixir):** The central orchestration engine.
    *   **Responsibilities:** Manages client sessions, enforces security and contracts, validates all tool calls against trusted schemas, and routes invocations to the appropriate Runtime. The Host is the ultimate authority on what tools can be executed.
*   **Runtime (Python, Elixir, etc.):** An external, language-specific process that provides the business logic for one or more tools.
    *   **Responsibilities:** Connects to the Host, advertises its capabilities to fulfill tool contracts, and executes the business logic of a tool upon receiving a `ToolCall`.
*   **Client (Python, Elixir):** The application or agent that initiates a tool call.
    *   **Responsibilities:** Communicates exclusively with the Host to create sessions and request tool executions.

Communication is defined by a language-agnostic protocol, with **gRPC** serving as the primary transport mechanism. The architecture is designed to be transport-agnostic, allowing for future implementations like WebSockets.

```mermaid
graph LR
    subgraph Client Apps
        C1[Elixir Client]
        C2[Python Client]
    end

    subgraph GRID Host (Elixir)
        direction TB
        H[Orchestration Core]
        SM[Session Manager]
        TM[Transport Manager]
        H --- SM & TM
    end

    subgraph Runtimes
        RT1["Python Runtime"]
        RT2["Elixir Runtime"]
    end

    Client Apps -- gRPC --> TM
    TM -- Tool Call --> H
    H -- Routes Call --> TM
    TM -- gRPC --> Runtimes

    style H fill:#4338ca,stroke:#3730a3,color:#ffffff
    style RT1 fill:#34d399,stroke:#25a274,color:#ffffff
    style RT2 fill:#34d399,stroke:#25a274,color:#ffffff
```

---

#### **3. Key Design Improvement: Development vs. Production Modes**

To address the critical bottleneck in multi-language development, the GRID Host will operate in one of two modes, selectable by configuration. This dual-mode design provides development agility while ensuring production security.

##### **3.1. STRICT Mode (Production Default)**

This mode enforces the foundational Host-centric security model of GRID.

*   **Contract Authority:** The Host is the **sole source of truth**. It loads a static, version-controlled `ToolManifest.json` file at startup. This manifest contains all approved `ToolContract` definitions.
*   **Runtime Role:** Runtimes can only announce that they are capable of *fulfilling* contracts that already exist in the Host's manifest. They cannot define or alter contracts.
*   **Workflow:**
    1.  A developer finalizes a tool (e.g., in Python).
    2.  They submit the tool's `ToolContract` (as JSON) to be included in the central `ToolManifest.json` file in source control.
    3.  After review and merge, the Elixir Host is redeployed, officially recognizing the new tool.
*   **Security:** High. Prevents unauthorized code execution and ensures all tool interactions are governed by centrally-vetted contracts.

##### **3.2. DEVELOPMENT Mode**

This mode is designed for rapid iteration and testing in trusted development environments.

*   **Contract Authority:** The Host's authority is relaxed. While it still loads the base manifest, it also accepts dynamic, on-the-fly tool registrations from Runtimes.
*   **Runtime Role:** Upon connecting, a Runtime can send a `RegisterTools` message containing the full `ToolContract` for new or modified tools. The Host will temporarily register these tools for the duration of that Runtime's session.
*   **Workflow:**
    1.  The Elixir team runs a shared Host in `DEVELOPMENT` mode.
    2.  A Python developer starts their local Runtime.
    3.  The Runtime connects to the dev Host and sends a `RegisterTools` message with its new tool contracts.
    4.  The developer can immediately start making calls to their new tool through the full Host -> Runtime loop for end-to-end testing.
*   **Security:** Low. This mode should **never** be used in production. It trusts the Runtimes to provide valid and safe tool contracts.

---

#### **4. Communication Protocol (gRPC)**

The protocol will be defined in a file named `altar_grid.proto`. It defines the services and messages for Host-Runtime communication. All data structures like `FunctionCall` and `ToolResult` are imported directly from the **ALTAR Data Model (ADM)** specification.

##### **Services**

*   **`GRIDRuntimeService`** (Implemented by Runtimes)
    *   `ExecuteTool(ToolCall) returns (ToolResult)`: The primary method for the Host to invoke a tool on a Runtime.

*   **`GRIDHostService`** (Implemented by the Host)
    *   `Announce(AnnounceRuntime) returns (AnnounceResponse)`: The initial handshake from a Runtime to the Host.
    *   `FulfillContracts(FulfillContractsRequest) returns (FulfillContractsResponse)`: Used in `STRICT` mode for a Runtime to declare which manifest contracts it can handle.
    *   `RegisterTools(RegisterToolsRequest) returns (RegisterToolsResponse)`: Used in `DEVELOPMENT` mode for a Runtime to dynamically register its tools.

##### **Key Messages**

*   `AnnounceRuntime`: Contains `runtime_id`, `language`, `version`, and other metadata.
*   `RegisterToolsRequest`: Contains a list of ADM-compliant `Tool` structures.
*   `ToolCall`: Wraps an ADM `FunctionCall` and adds a unique `invocation_id` for tracing.
*   `ToolResult`: Wraps an ADM `ToolResult` and includes the corresponding `invocation_id`.

---

#### **5. Component Specifications**

##### **5.1. The Elixir Host**

*   **Core Logic:** The Host's business logic will be pure Elixir, focusing on session management, orchestration, and ADM validation.
*   **Transport Layer:** The Host will be built with a pluggable transport behavior. The initial implementation, `Altar.GRID.Transport.GRPC`, will handle all gRPC communication. This decoupled design allows future transports (e.g., WebSockets) to be added without altering the core orchestration logic, ensuring the system is future-proof.
*   **Configuration:** A clear application environment flag (e.g., `config :altar, grid_mode: :strict`) will determine the operational mode.

##### **5.2. Client Libraries (Elixir & Python)**

A high-quality developer experience is paramount. To support this, the GRID ecosystem must include canonical client libraries.

*   **Canonical Python Library:**
    *   **`AltarRuntime`:** A simple runtime server class that handles the gRPC boilerplate. A developer can use a decorator (`@tool`) on their Python functions to automatically expose them. The runtime will handle the handshake (`Announce`, `RegisterTools`) and dispatching.
    *   **`AltarClient`:** A clean client API for connecting to the Host, creating sessions, and making tool calls.
    *   **ADM Classes:** A set of Python data classes that mirror the ADM structures for a typed and intuitive experience.

*   **Canonical Elixir Library:**
    *   Provides equivalent `Altar.Runtime` and `Altar.Client` modules for Elixir developers to easily build Runtimes and client applications.

---

#### **6. Testing Strategy**

The project will be validated using a three-tiered testing strategy, implemented in both the core library and a new `examples/` directory.

1.  **Unit Tests:** Test the pure logic of ADM structures, Host orchestration, and Runtime dispatching in isolation.
2.  **Integration Tests:** Test the Host's logic by mocking the transport layer and runtimes. This allows for rapid testing of session management and validation without network overhead.
3.  **End-to-End (E2E) Tests:** A dedicated test suite will spin up a real Elixir Host application and a real Python Runtime as separate OS processes. The tests will make calls over a real gRPC connection and assert the correctness of the results, proving the entire multi-language system works as specified.

The `examples/` directory will serve as a runnable "starter kit" that provides canonical, minimal implementations of a Host, a Python Runtime, and clients, acting as both documentation and the ultimate proof of the platform's usability.
